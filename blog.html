<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- tailwind and daisyui link -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@2.24.0/dist/full.css" rel="stylesheet" type="text/css" />

    <title>Moment's Hunter News</title>

</head>


<body class="bg-base-200 mx-auto">

    <header>

        <!-- Navbar star -->
        <div class="navbar bg-base-100 mx-auto w-11/12">
            <div class="flex-1">
                <a class="btn btn-ghost normal-case text-2xl text-sky-500">Moment's Hunter News</a>
            </div>
            <div class="flex-none gap-2">
                <div class="flex-none">
                    <ul class="menu menu-horizontal p-0">
                        <li><a href="index.html">News</a></li>
                        <li><a href="blog.html">Blog</a></li>
                    </ul>
                </div>
            </div>
            <div class="dropdown dropdown-end">
                <label class="btn btn-ghost btn-circle avatar">
                    <div class="w-10 rounded-full">
                        <img src="img/avater.jpg" />
                    </div>
                </label>

            </div>
        </div>
        <div class="mt-2 mx-auto w-11/12">
            <hr>
        </div>

        <!-- Navbar end -->
    </header>

    <main>
        <div class="bg-base-100 mx-16 my-5 p-8">
            <h1 class="text-3xl font-semibold">Var, Let, এবং Const এর পার্থক্য কি?</h1>
            <p class="text-2xl mx-20 ">ES2015 (ES6) এর সাথে অনেক গুলো নতুন ফিচার এসেছে এবং, যেহেতু এখন ২০২০, ধরে নেওয়া
                যায় যে অধিকাংশ জাভাস্ক্রিপ্ট ডেভেলপারই এই ফিচারগুলোর সাথে পরিচিত এবং তাঁরা এগুলো ব্যবহারও করছেন।

                যদিও এই ধারণাটা আংশিক সত্য, তবে অনেকের কাছেই এই ফিচার গুলো এখনো অজানা থাকা টা অসম্ভব কিছু নয়।

                ES6 এর সাথে আসা ফিচারগুলোর একটি হল let এবং const কীওয়ার্ড, যেগুলোকে ভ্যারিয়েবল ডিক্লেয়ার করার সময়
                ব্যবহার করা যায়। প্রশ্ন হল আমাদের পুরনো var কীওয়ার্ডের সাথে এদের পার্থক্যটা কোথায়? যদি আপনি এটা নিয়ে
                দ্বিধায় ভুগেন, তাহলে এই আর্টিকেলটি আপনার জন্যই।

                এই আর্টিকেলে আমরা var, let, এবং const এর scope, ব্যবহার, এবং hoisting নিয়ে আলোচনা করবো। এই কীওয়ার্ডগুলোর
                পার্থক্য আমি দেখাবো, পড়ার সময় আপনি চাইলে সেগুলো নোট করে নিতে পারেন।

                Var
                ES6 এর আবির্ভাব ঘটার আগে var ডেক্লারেশনের ব্যবহার ছিল সর্বত্র। যদিও এই কীওয়ার্ড দিয়ে ডিক্লেয়ার করা
                ভ্যারিয়েবলের বেশ কিছু সমস্যা ছিল। এ কারণেই ভ্যারিয়েবল ডিক্লেয়ার করার একটি নতুন পদ্ধতির প্রয়োজন প্রকট হয়ে
                গিয়েছিল। var এর সমস্যাগুলো বুঝার আগে চলুন var সম্পর্কে আরও কিছুটা জেনে নেই।

                Var এর scope
                একটি ভ্যারিয়েবলের scope বলতে বুঝায়, ভ্যারিয়েবলটি কোডের কোন অংশে ব্যবহার করা যায়। var ডেক্লারেশন হতে পারে
                globally scoped অথবা function scoped।

                যখন var ব্যবহার করে একটি ভ্যারিয়েবলকে কোন ফাংশনের বাহিরে ডিক্লেয়ার করা হয়, তখন ভ্যারিয়েবলটি global
                scope-এ থাকে। অর্থাৎ, ফাংশন ব্লকের বাহিরে var কীওয়ার্ড ব্যবহার করে ডিক্লেয়ার করা যে কোন ভ্যারিয়েবল,
                সম্পূর্ণ উইন্ডোতে (window object) ব্যবহার করা যায়।

                আবার যখন var ব্যবহার করে একটি ভ্যারিয়েবলকে কোন ফাংশন ব্লকের ভেতরে ডিক্লেয়ার করা হয়, তখন সেটা function
                scoped হয়। অর্থাৎ এটি শুধুমাত্র ঐ ফাংশনটির ভেতরেই ব্যবহার করা যায়।

                নিচের উদাহরণটি দেখুন।

                var greeter = "hey hi";

                function newFunction() {
                var hello = "hello";
                }
                এখানে greeter globally scoped কারণ, এটি ফাংশন ব্লকের বাহিরে আছে কিন্তু hello function scoped, তাই আমরা
                hello ভ্যারিয়েবলটিকে ফাংশনের বাহিরে ব্যবহার করতে পারবো না। সুতরাং, আমরা যদি এটা করার চেষ্টা করিঃ

                var tester = "hey hi";

                function newFunction() {
                var hello = "hello";
                }
                console.log(hello); // error: hello is not defined
                যেহেতু, hello ভ্যারিয়েবলটি ফাংশনের বাহিরে ব্যবহারযোগ্য নয়, জাভাস্ক্রিপ্ট এটিকে undefined হিসেবে ধরে নেয়
                এবং এরর মেসেজটি দেখায়।

                var ভ্যারিয়েবলগুলো রিডিক্লেয়ার এবং আপডেট করা যায়
                অর্থাৎ আমরা একই scope-এ কোন সমস্যা ছাড়াই নিচের কাজটি করতে পারি

                var greeter = "hey hi";
                var greeter = "say Hello instead";
                এবং এটাও

                var greeter = "hey hi";
                greeter = "say Hello instead";
                var এর hoisting
                জাভাস্ক্রিপ্ট এর একটি মেকানিজম হল hoisting, যার বাংলা অর্থ করলে দাঁড়ায় উত্তোলন।hoisting এর কারণে কোড
                এক্সিকিউশনের আগে, জাভাস্ক্রিপ্ট ইঞ্জিন, কোডের ভ্যারিয়েবল এবং ফাংশন ডেক্লারেশনগুলোকে তাদের স্কোপ এর উপরে
                নিয়ে রাখে। আমরা যদি নিচের কোড চালাইঃ

                console.log (greeter);
                var greeter = "say hello"
                hoisting এর কারণে জাভাস্ক্রিপ্ট ইঞ্জিন এই কোডকে নিচের মত করে দেখবেঃ

                var greeter;
                console.log(greeter); // greeter is undefined
                greeter = "say hello"
                সুতরাং var দিয়ে ডিক্লেয়ার করা ভ্যারিয়েবল গুলোকে hoisting এর মধ্যমে তাদের স্কোপের উপরে নিয়ে যাওয়া হয় এবং
                ভ্যারিয়েবলগুলোর মান হিসেবে undefined বসিয়ে দেওয়া হয়।

                var এর কিছু সমস্যা
                var এর কিছু দুর্বলতা আছে। ব্যাখ্যা করার জন্য আমি নিচের উদাহরণটি ব্যবহার করবঃ

                var greeter = "hey hi";
                var times = 4;

                if (times > 3) {
                var greeter = "say Hello instead";
                }

                console.log(greeter) // "say Hello instead"
                যেহেতু times > 3 এর মান true হয়, greeter এর মান রিডিফাইন হয়ে "say Hello instead" হবে। যদি আপনি ইচ্ছে
                করেই greeter ভ্যারিয়েবলটি রিডিফাইন করেন, তাহলে সমস্যা নেই, তবে সমস্যার সৃষ্টি হবে যখন আপনি জানবেন না যে
                greeter ভ্যারিয়েবলটি আগেই একবার ডিফাইন করা হয়েছে।

                যদি আপনি কোডের অন্য কোন অংশে greeter ভ্যারিয়েবলটি ব্যবহার করে থাকেন, তাহলে কোডের আউটপুট আপনার আশানুরূপ
                নাও হতে পারে। এর কারণে আপনার কোডে অনেক বাগও তৈরি হতে পারে। এজন্যই let এবং const ব্যবহার করা জরুরি।

                Let
                ভ্যারিয়েবল ডেক্লারেশনের জন্য এখন let বেশি ব্যবহার করা হয়। var ডেক্লারেশনের থেকে let অনেক উন্নত এবং এটি
                var এর সমস্যাগুলোকেও সমাধান করে। চলুন দেখা যাক কিভাবে সেটা হয়।

                let হল block scoped
                একটি ব্লক হল {} দিয়ে আবদ্ধ কোড এর অংশ। এই বন্ধনীগুলোর মধ্যে যা কিছু আছে তার সবকিছুই একটি ব্লক।

                সুতরাং, কোন ব্লকের ভেতরে let ব্যবহার করে ডিক্লেয়ার করা ভ্যারিয়েবল শুধুমাত্র ঐ ব্লকের মধ্যেই ব্যবহার করা
                যাবে। একটি উদাহরণ দিয়ে ব্যাখ্যা করিঃ

                let greeting = "say Hi";
                let times = 4;

                if (times > 3) {
                let hello = "say Hello instead";
                console.log(hello);// "say Hello instead"
                }
                console.log(hello) // hello is not defined
                আমরা দেখতে পাচ্ছি যে ব্লকের বাহিরে hello ব্যবহার করতে চাইলে একটি এরর মেসেজ দেখা দেয়। এর কারণ হল let
                ভ্যারিয়েবলগুলো block scoped।

                let আপডেট করা যায় তবে রিডিক্লেয়ার করা যায় না
                var এর মতই, let ব্যবহার করে ডিক্লেয়ার করা ভ্যারিয়েবলকে তার scope-এর মধ্যে আপডেট করা যায় তবে রিডিক্লেয়ার
                করা যায় না। সুতরাং যদিও নিম্নোক্ত কোডটি ঠিকঠাক কাজ করবেঃ

                let greeting = "say Hi";
                greeting = "say Hello instead";
                এরপরের কোডটি এরর রিটার্ন করবেঃ

                let greeting = "say Hi";
                let greeting = "say Hello instead"; // error: Identifier 'greeting' has already been declared
                তবে একই নামের ভ্যারিয়েবল যদি আলাদা আলাদা scope-এ থাকে, তাহলে কোন এরর দেখা দেবে নাঃ

                let greeting = "say Hi";
                if (true) {
                let greeting = "say Hello instead";
                console.log(greeting); // "say Hello instead"
                }
                console.log(greeting); // "say Hi"
                এখানে কোন এরর নেই কেন বলুন তো? আলাদা আলাদা scope-এ থাকার কারণে ভ্যারিয়েবলের ইন্সট্যান্সদুটোকে সম্পূর্ণ
                আলাদা ভ্যারিয়েবল হিসেবে ধরা হয়।

                var এর থেকে let বেশি ভাল হওয়ার পেছনে এটি একটি কারণ। let ব্যবহার করলে কোন ভ্যারিয়েবলের নাম আপনি আগে
                ব্যবহার করেছেন কিনা, সেটা নিয়ে চিন্তা করার কোন দরকার নেই।

                আবার, যেহেতু একই scope-এ একই নামে একাধিক ভ্যারিয়েবল ডিক্লেয়ার করা যায় না সুতরাং, var নিয়ে এর আগে যে
                সমস্যা আমরা আলোচনা করেছি সেটাও ঘটার সুযোগ নেই।

                let এর hoisting
                var এর মতই let এও hoisting ঘটে। তবে var এর মান হিসেবে যেমন undefined বসিয়ে দেওয়া হয়, let এর ক্ষেত্রে কোন
                মান দেওয়া হয় না। যার ফলে, ডেক্লারেশনের আগে let ভ্যারিয়েবল ব্যবহার করতে চাইলে Reference Error দেখা দেয়।

                Const
                const ব্যবহার করে ডিক্লেয়ার করা ভ্যারিয়েবলগুলো হল ধ্রুবক অর্থাৎ অপরিবর্তনীয়। const ডেক্লারশনগুলো
                অনেকাংশে let এর মতই।

                const ডেক্লারেশনগুলোও block scoped
                let ডেক্লারেশনের মতই, const ডেক্লারেশনগুলোও যে ব্লকে ডিক্লেয়ার করা হয়েছে, শুধুমাত্র সেই ব্লকেই ব্যবহার
                করা যায়।

                const রিডিক্লেয়ার বা আপডেট করা যায় না
                অর্থাৎ, const দিয়ে ডিক্লেয়ার করা ভ্যারিয়েবল তার scope-এর মধ্যে অপরিবর্তিত থাকবে। এটা আপডেট অথবা
                রিডিক্লেয়ার করা যাবে না। সুতরাং, যদি আমরা কোন ভ্যারিয়েবলকে const দিয়ে ডিক্লেয়ার করি, তাহলে আমরা
                নিম্নোক্ত কাজটি করতে পারবো নাঃ

                const greeting = "say Hi";
                greeting = "say Hello instead";// error: Assignment to constant variable.
                এমনকি এটাও নাঃ

                const greeting = "say Hi";
                const greeting = "say Hello instead";// error: Identifier 'greeting' has already been declared
                প্রত্যেকটি const ভ্যারিয়েবলকে ডেক্লারেশনের সময়ই একটি মান দিতে হয়।

                তবে const ব্যবহার করে ডিক্লেয়ার করা অবজেক্টের ক্ষেত্রে ঘটনা কিছুটা আলাদা। যদিও একটি const অবজেক্টকে
                আপডেট করা যায় না, তবে তার ভেতরের প্রোপার্টিগুলোকে আপডেট করা যায়। সুতরাং, যদি আমরা নিম্নোক্ত উপায়ে একটি
                const অবজেক্ট ডিক্লেয়ার করিঃ

                const greeting = {
                message: "say Hi",
                times: 4
                }
                তাহলে আমরা এটা করতে পারব নাঃ

                greeting = {
                words: "Hello",
                number: "five"
                } // error: Assignment to constant variable.
                তবে আমরা এটা করতে পারিঃ

                greeting.message = "say Hello instead";
                এই কোডটি কোন এরর ছাড়াই greeting.message এর মান আপডেট করে ফেলবে।

                const এর হোয়েস্টিং
                let ডেক্লারেশনের মত const ডেক্লারেশনগুলোতেও hoisting হয়, তবে ইনিশিয়ালাইজেশন হয় না।

                তো, যদি আপনি এখনো let, const, এবং var এর পার্থক্য বুঝতে না পারেন, তাহলে নিচের বুলেট পয়েন্টগুলো আপনাকে
                বুঝতে সহায়তা করবেঃ

                var ডেক্লারেশনগুলো globally scoped অথবা function scoped হতে পারে, তবে let এবং const শুধু block scoped
                হয়।
                var ভ্যারিয়েবলগুলোকে তাদের scope-এর মধ্যে আপডেট এবং রিডিক্লেয়ার করা যায়; let ভ্যারিয়েবলগুলোকে আপডেট করা
                গেলেও রিডিক্লেয়ার করা যায় না; const ভ্যারিয়েবলগুলোকে আপডেট বা রিডিক্লেয়ার কোনটাই করা যায় না।
                এই তিন ধরণের ডেক্লারেশনকেই তাদের scope-এর উপরে hoist করা হয়। তবে var গুলোকে undefined মান দেওয়া হলেও let
                এবং const গুলোকে কোন মান দেওয়া হয় না।
                var এবং let কে কোন মান ছাড়াই ডিক্লেয়ার করা গেলেও, const গুলোকে অবশ্যই ডিক্লেয়ার করার সময় মান দিতে হবে।
            </p>
        </div>
        <div class="bg-base-100 mx-16 my-5 p-8">
            <h1 class="text-3xl font-semibold">Arrow Function এবং Normal Function এর পার্থক্য কি?</h1>
            <p class="text-2xl mx-20 ">
                Arrow Function:
                অ্যারো ফাংশন হল ES6 এর একটি ফাংশন। এটি ফাংশন ডেফিনেশনকে আরো সহজ ও ক্লিন করেছে। বিশেষ করে anonymous
                function লিখার সময় একটি ঝামেলা লাগত। এটি ব্যবহার করা হলে কোড আরো ক্লিক এবং রিডেবল হয়ে উঠে। তবে এটি এখনো
                সব ব্রাউজার সার্পোট না থাকায় ব্যবহার করার ক্ষেত্রে সতর্ক থাকা উঠিত। তবে মর্ডান সব ব্রাউজারে এটি ব্যবহার
                করা যাবে।

                অ্যারো ফাংশন ছাড়া কোড

                btn1.addEventListener('click', function(){
                console.log("Anonymous Function")
                })Copy
                অ্যারো ফাংশন ব্যবহার করে ৩ লাইনের কোড ১ লাইনে :)

                btn1.addEventListener('click', () => console.log("Arrow Function"))

                <br>
                <br><br>
                Normal Function
                Normal/Regular function এর সাথে আমরা সবাই পরিচিত যেখানে function কীওয়ার্ডটির সাথে একটি ফাংশনের নাম দিতে
                হয়। যদি কোন আরগুমেন্ট প্রয়োজন হয় তা সচারচর নিয়মে ডিফাইন করা হয়। যেমন নিচের মত দেখতে একটি NormalRegular
                Function.

                function myFunction(){
                console.log('This is normal function');
                }
            </p>
        </div>
        <div class="bg-base-100 mx-16 my-5 p-8">
            <h1 class="text-3xl font-semibold">টেমপ্লেট স্ট্রিং কি, কেন ইউজ করবো?</h1>
            <p class="text-2xl mx-20 ">আমাদের জাভাস্ক্রিপ্ট এ একটা স্ট্রিং কয়েকটা ভ্যারিয়েবলসহ প্রিন্ট করাতে চাইলে
                আমাদের সেই ভ্যারিয়েবলগুলোকে কনক্যাট করে নিতে হয় + চিহ্নের সাহায্যে। ব্যাপারটা আসলেই একটু বিরক্তকর ছিলো।
                অনেক বড় স্ট্রিং এর ক্ষেত্রে খুব সহজেই হারিয়ে যাওয়ার মতো অবস্থা ছিলো। যেমন নিচের এই উদাহরনে আমি আমার কিছু
                ইনফরমেশন কয়েকটা ভ্যারিয়েবল থেকে নিয়ে প্রিন্ট করাতে চাচ্ছিঃ

                var name = 'Zonayed Ahmed',
                age = 21,
                work= 'Student';
                console.log('My name is ' + name + ' and I\'m ' + age + 'years old! Currently I\'m a ' + work);
                এটা এক্সিকিউট করলে এভাবে আউটপুট আসবেঃ


                এখানে আমাদের প্লাস + চিহ্ন দিয়ে ভ্যারিয়েবলগুলোকে আমার স্ট্রিংগুলোর সাথে কনক্যাট করতে হয়েছে। এটাও ঠিক
                আছে, কিন্তু বার বার এভাবে ‘ দিয়ে স্ট্রিং গুলোকে বেধে দিয়ে + দিয়ে এভাবে ভ্যারিয়েবলগুলোকে অ্যাক্সেস করা
                ঝামেলাপূর্ণ। অনেকসময় দেখা যায় বড় স্ট্রিং এর ক্ষেত্রে দুই একটা ‘ মিস হয়ে গেছে। আবার দেখুন এখানে I’m লেখার
                জন্যে এসকেপ ক্যারেক্টার \ ইউজ করতে হয়েছে। ওভারল এটা একটা মেস হয়ে গেছে।

                আর এইজন্যেই ইএস এ এসেছে টেমপ্লেট লিটারেল। এর প্রধান কাজ হচ্ছে এই স্ট্রিং কনক্যাটিনেশনের কমপ্লেক্সিটি
                কমানো। টেমপ্লেট লিটারেলে আমরা এই চিহ্ন ` (ব্যাকটিক, ট্যাব tab কীর উপরে) ইউজ করে পুরো স্ট্রিং টাকে বেঁধে
                ফেলি, তারপর ভিতরে কোনো ভ্যারিয়েবল বা সিম্পল ক্যাল্কুলেশন করতে চাইলে ${} এর ভিতরে রাখি। সেইম জিনিসটাই
                টেমপ্লেট লিটারেল দিয়ে প্রিন্ট করলেঃ

                const name6 = 'Zonayed Ahmed',
                age6 = 21,
                work6 = 'Student';
                console.log(`My name is ${name6} and I\'m ${age6}years old! Currently I\'m a ${work6}`);
                এটার আউটপুট আসবে এরকমভাবেঃ


                এখানে আমি const দিয়ে ভ্যারিয়েবল ডিক্লেয়ার করলেও আপনি চাইলে var বা letও ইউস করতে পারবেন। আমি জাস্ট যেহেতু
                ইএস ৬ এ কোড লিখছি, তাই পুরোটাই ইএস ৬ এ লিখলাম।

                এই কোডটা অবশ্যই আগেরটার চাইতে ঝামেলা কম এবং দেখতে অনেকটা ক্লিন দেখাচ্ছে। সেই সাথে ভিতরে আপনি যেকোনো
                ক্যারেক্টারই ইউজ করতে পারবেন এসকেপ না করে। স্মার্ট!

                আরো কিছু উদাহরন টেমপ্লেট লিটারেল নিয়েঃ

                function calculateAge(dob) {
                return `I'm ${2018 - dob} years old!`;
                }
                calculateAge(1996);

                এভাবেই ইএস ৬ এর টেমপ্লেট লিটারেল ইউজ করে আরো ক্লিন এবং সহজভাবে, সুন্দর করে কোড লিখতে পারবেন কোনো ঝামেলা
                ছাড়াই।</p>
        </div>



    </main>


    <section>


    </section>







</body>

</html>